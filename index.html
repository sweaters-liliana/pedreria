<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>JMVN - Generador Pro V3.6 (Full Effects & Touch Zoom)</title>
    <style>
        :root { --accent: #ff0055; --bg: #111; --text: #eee; --panel: #222; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); display: flex; flex-direction: column; align-items: center; padding: 20px; margin: 0; touch-action: none; }
        
        header { text-align: center; margin-bottom: 20px; width: 100%; position: relative; }
        h1 { margin: 0; font-size: 2.2rem; letter-spacing: 2px; text-transform: uppercase; }
        .red-text { color: var(--accent); } .white-text { color: white; }

        /* Botonera Header */
        .header-controls { position: absolute; right: 20px; top: 10px; display: flex; gap: 10px; }
        .header-btn { background: #333; border: 1px solid #555; padding: 8px 15px; border-radius: 5px; color: white; cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 0.9rem; }
        .header-btn:hover { background: #444; border-color: var(--accent); }

        .container { background: var(--panel); padding: 25px; border-radius: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.8); width: 95%; max-width: 1400px; display: grid; grid-template-columns: 320px 1fr; gap: 25px; }
        
        /* Controles */
        .controls { display: flex; flex-direction: column; gap: 12px; height: fit-content; max-height: 90vh; overflow-y: auto; }
        .control-group { background: #333; padding: 12px; border-radius: 10px; border: 1px solid #444; }
        .control-group.project-meta { border-color: var(--accent); background: #2a1a1f; }
        
        label { display: block; font-size: 0.85rem; color: #aaa; margin-bottom: 6px; }
        input[type="text"], input[type="file"], input[type="number"], select, textarea { width: 100%; padding: 8px; background: #222; border: 1px solid #555; color: white; border-radius: 4px; box-sizing: border-box; }
        input[type="range"] { width: 100%; cursor: pointer; }
        
        button { background: var(--accent); color: white; border: none; padding: 12px; border-radius: 6px; cursor: pointer; font-weight: bold; width: 100%; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; font-size: 0.9rem; transition: 0.2s; }
        button:hover { filter: brightness(1.2); }
        button:disabled { background: #555; cursor: not-allowed; opacity: 0.7; }
        button.edit-mode-btn { background: #2196F3; box-shadow: 0 4px 10px rgba(33, 150, 243, 0.3); }
        button.text-tool-btn { background: #9C27B0; margin-bottom: 15px; box-shadow: 0 4px 10px rgba(156, 39, 176, 0.3); }

        .val { float: right; color: var(--accent); font-weight: bold; }
        .dimensions-display { text-align: center; color: #00E676; font-family: monospace; font-size: 1.1rem; margin-top: 10px; }

        /* √Årea de SVG / Canvas */
        #visualWrapper { background: #fff; border-radius: 8px; height: 650px; position: relative; overflow: hidden; box-shadow: inset 0 0 20px rgba(0,0,0,0.2); display: flex; align-items: center; justify-content: center; }
        #svgContent { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; }
        
        /* --- MODO EDICI√ìN (OVERLAY) --- */
        #editorOverlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: #1a1a1a; z-index: 100; display: none; flex-direction: column; 
        }
        #editorCanvas { flex-grow: 1; cursor: grab; background: #e0e0e0; touch-action: none; }
        #editorCanvas:active { cursor: grabbing; }

        .editor-toolbar {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 30px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5); pointer-events: auto;
        }
        .tool-btn {
            width: 45px; height: 45px; border-radius: 50%; border: 2px solid transparent;
            background: #333; color: white; font-size: 1.2rem; cursor: pointer; display: flex; align-items: center; justify-content: center;
        }
        .tool-btn.active { border-color: white; transform: scale(1.1); }
        .tool-btn.delete.active { background: var(--accent); }
        .tool-btn.add.active { background: #00E676; color: black; }
        .tool-btn.move.active { background: #2196F3; }

        .editor-actions {
            position: absolute; bottom: 20px; width: 100%; display: flex; justify-content: center; gap: 20px; pointer-events: none;
        }
        .editor-actions button { pointer-events: auto; width: 140px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .btn-confirm { background: #00C853; }
        .btn-discard { background: #D50000; }

        /* --- MODALES GENERALES --- */
        .modal-backdrop {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 200; display: none;
            justify-content: center; align-items: center;
        }
        .modal-content {
            background: #222; padding: 25px; border-radius: 12px; width: 90%; max-width: 850px; 
            border: 1px solid #444; max-height: 90vh; overflow-y: auto; text-align: center; position: relative;
        }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .close-btn { background: none; border: none; font-size: 1.5rem; cursor: pointer; width: auto; padding: 0; color: #888; }
        
        /* Lista de Proyectos */
        .project-list { list-style: none; padding: 0; margin: 0; text-align: left; }
        .project-item { 
            background: #333; margin-bottom: 10px; padding: 15px; border-radius: 8px; 
            display: flex; justify-content: space-between; align-items: center; border: 1px solid #333;
        }
        .project-item:hover { border-color: var(--accent); }
        .p-info h4 { margin: 0 0 5px 0; color: white; }
        .p-info span { font-size: 0.8rem; color: #aaa; }
        .btn-load { width: auto; padding: 8px 20px; font-size: 0.8rem; background: #2196F3; }

        /* Opciones de Exportaci√≥n */
        .export-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-top: 20px; }
        .export-option { background: #333; padding: 20px; border-radius: 8px; cursor: pointer; border: 2px solid transparent; transition: 0.2s; }
        .export-option:hover { border-color: var(--accent); background: #2a1a1f; }
        .export-icon { font-size: 2rem; margin-bottom: 10px; display: block; }
        .export-label { font-weight: bold; color: white; display: block; }

        /* --- ESTILOS MODAL TEXTO (MODULAR) --- */
        .text-preview-area { 
            background: #fff; height: 160px; display: flex; align-items: center; justify-content: center; 
            border-radius: 8px; margin-bottom: 15px; overflow: hidden; 
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%); 
            background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px; 
        }

        .text-inputs-row {
            display: grid; grid-template-columns: 1.5fr 1fr 1fr; gap: 15px;
            background: #333; padding: 15px; border-radius: 10px; margin-bottom: 20px;
            text-align: left; align-items: center;
        }

        .effects-container { text-align: left; }
        .effects-label { font-size: 1.1rem; color: var(--accent); font-weight: bold; margin-bottom: 10px; display: block; }
        
        /* IFRAME CONTAINER PARA EFECTOS */
        #effectsFrame {
            width: 100%;
            height: 380px;
            border: 2px solid #444;
            border-radius: 8px;
            background: #111;
        }

        .font-item { display: flex; justify-content: space-between; background: #333; padding: 10px; margin-bottom: 5px; border-radius: 5px; align-items: center; }

        /* Controles de Flechas para MOVER */
        #dpad {
            position: absolute; bottom: 90px; right: 20px; width: 120px; height: 120px;
            display: none; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr;
            pointer-events: auto; opacity: 0.8;
        }
        .d-btn { background: #444; border: 1px solid #666; color: white; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-weight: bold; }
        .d-btn:active { background: #2196F3; }
        
        .footer { margin-top: 30px; text-align: center; color: #555; font-size: 0.9rem; border-top: 1px solid #333; padding-top: 20px; width: 100%; }
        .gemini-tag { color: var(--accent); font-weight: bold; font-size: 0.8rem; letter-spacing: 1px; display: block; margin-top: 5px; }

        @media (max-width: 900px) { 
            .container { grid-template-columns: 1fr; } 
            #visualWrapper { height: 500px; } 
            .header-controls { position: relative; right: auto; top: auto; display: flex; margin-bottom: 15px; justify-content: center; } 
            .text-inputs-row { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

    <header>
        <h1><span class="red-text">HERRAMIENTAS INTELIGENTES</span> <span class="white-text">JMVN</span></h1>
        <div class="header-controls">
            <button class="header-btn" onclick="openFontManager()">üÖ∞Ô∏è Gesti√≥n Fuentes</button>
            <button class="header-btn" onclick="openGallery()">üìÇ Ver Dise√±os</button>
        </div>
    </header>

    <div class="container">
        <div class="controls">
            <button class="text-tool-btn" onclick="openTextTool()">‚ú® CREAR TEXTO M√ÅGICO ‚ú®</button>

            <div class="control-group project-meta">
                <label style="color:white; font-weight:bold;">NOMBRE DEL PROYECTO *</label>
                <input type="text" id="projectName" placeholder="Ej: Logo Versace 01" autocomplete="off">
            </div>

            <div class="control-group" id="imgInputGroup">
                <label>1. O Cargar Imagen (Si no usas texto)</label>
                <input type="file" id="imageInput" accept="image/*">
            </div>

            <div class="control-group">
                <label>2. Configuraci√≥n F√≠sica</label>
                <label style="font-size:0.75rem">Ancho Real de Impresi√≥n (cm):</label>
                <input type="number" id="realWidthCm" value="25" step="0.5">
            </div>

            <div class="control-group">
                <label>3. Distribuci√≥n</label>
                <select id="mode" class="param-input">
                    <option value="adaptive">Trazo Adaptativo (Curvas)</option>
                    <option value="honeycomb">Panal Org√°nico</option>
                    <option value="grid">Ladrillo Recto</option>
                </select>
            </div>

            <div class="control-group">
                <label>Separaci√≥n Vertical: <span id="yStepVal" class="val">--</span> mm</label>
                <input type="range" id="yStep" class="param-input" min="2" max="40" value="8">
            </div>

            <div class="control-group">
                <label>Densidad Horizontal: <span id="xStepVal" class="val">--</span> mm</label>
                <input type="range" id="xStep" class="param-input" min="2" max="40" value="8">
            </div>

            <div class="control-group">
                <label>√Ångulo: <span id="angleVal" class="val">0</span>¬∞</label>
                <input type="range" id="angle" class="param-input" min="-45" max="45" value="0">
            </div>

            <div class="control-group">
                <label>Tama√±o Piedra (aprox): <span id="radiusVal" class="val">--</span> mm</label>
                <input type="range" id="radius" class="param-input" min="1" max="20" step="0.5" value="2.5">
            </div>

            <button onclick="processImage()" id="btnGenerate">Generar Trama Base</button>
            <button class="edit-mode-btn" id="btnOpenEditor" onclick="openEditor()" disabled>üõ†Ô∏è Entrar a Modo Edici√≥n</button>
            <div class="dimensions-display" id="dimDisplay">0 cm x 0 cm</div>
        </div>

        <div id="visualWrapper">
            <div id="svgContent">
                <div style="color:#bbb; text-align:center">Usa "Crear Texto M√°gico" o sube imagen<br>para comenzar.</div>
            </div>

            <div id="editorOverlay">
                <div class="editor-toolbar">
                    <button class="tool-btn delete active" onclick="setTool('delete')" title="Eliminar (Rojo)">üóëÔ∏è</button>
                    <button class="tool-btn add" onclick="setTool('add')" title="Agregar (Verde)">‚ûï</button>
                    <button class="tool-btn move" onclick="setTool('move')" title="Mover (Azul)">‚úã</button>
                </div>

                <canvas id="editorCanvas"></canvas>
                
                <div id="dpad">
                    <div></div><button class="d-btn" onclick="nudge(0,-1)">‚ñ≤</button><div></div>
                    <button class="d-btn" onclick="nudge(-1,0)">‚óÄ</button>
                    <button class="d-btn" style="background:#2196F3; border:none;">‚óè</button>
                    <button class="d-btn" onclick="nudge(1,0)">‚ñ∂</button>
                    <div></div><button class="d-btn" onclick="nudge(0,1)">‚ñº</button><div></div>
                </div>

                <div class="editor-actions">
                    <button class="btn-discard" onclick="discardChanges()">Descartar ‚ùå</button>
                    <button class="btn-confirm" onclick="confirmChanges()">CONFIRMAR ‚úÖ</button>
                </div>
            </div>
        </div>
    </div>

    <div id="galleryModal" class="modal-backdrop">
        <div class="modal-content">
            <div class="modal-header">
                <h3 style="margin:0">Dise√±os Guardados</h3>
                <button class="close-btn" onclick="closeModal('galleryModal')">√ó</button>
            </div>
            <div id="galleryList" class="project-list"></div>
        </div>
    </div>

    <div id="fontManagerModal" class="modal-backdrop">
        <div class="modal-content">
            <div class="modal-header">
                <h3 style="margin:0">Gestor de Fuentes</h3>
                <button class="close-btn" onclick="closeModal('fontManagerModal')">√ó</button>
            </div>
            <div style="text-align:left; margin-bottom:20px; background:#333; padding:15px; border-radius:8px;">
                <label>Nombre de la Fuente</label>
                <input type="text" id="newFontName" placeholder="Ej: Versace Font">
                <label style="margin-top:10px;">URL del archivo (.ttf, .otf o Google Font URL)</label>
                <input type="text" id="newFontUrl" placeholder="https://...">
                <button onclick="saveNewFont()" style="margin-top:10px; background:#00E676; color:black;">+ Agregar a Base de Datos</button>
            </div>
            <h4 style="text-align:left">Fuentes Disponibles:</h4>
            <div id="fontListDisplay" class="project-list" style="max-height:200px; overflow-y:auto;"></div>
        </div>
    </div>

    <div id="textToolModal" class="modal-backdrop">
        <div class="modal-content" style="max-width:900px;">
            <div class="modal-header">
                <h3 style="margin:0">‚ú® Dise√±ador de Texto M√°gico</h3>
                <button class="close-btn" onclick="closeModal('textToolModal')">√ó</button>
            </div>
            
            <div class="text-preview-area">
                <canvas id="textPreviewCanvas" height="160"></canvas>
            </div>

            <div class="text-inputs-row">
                <div>
                    <label>Texto:</label>
                    <textarea id="txtString" rows="1" style="resize:none; font-size:1.1rem; letter-spacing:1px;" oninput="updateTextPreview()">VERSACE</textarea>
                </div>
                <div>
                    <label>Fuente:</label>
                    <select id="txtFontFamily" onchange="updateTextPreview()">
                        <option value="Arial">Arial (Sistema)</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Impact">Impact</option>
                        <option value="Courier New">Courier New</option>
                        </select>
                </div>
                <div>
                    <label>Tama√±o / Intensidad:</label>
                    <input type="range" id="rngTxtSize" min="40" max="300" value="120" oninput="updateTextPreview()" title="Tama√±o Texto">
                    <input type="range" id="rngScatter" min="10" max="100" value="40" oninput="updateTextPreview()" style="margin-top:5px;" title="Intensidad Efecto">
                </div>
            </div>

            <div class="effects-container">
                <span class="effects-label">üìö Cat√°logo de Efectos (Cargado desde M√≥dulo Externo)</span>
                
                <iframe id="effectsFrame" src="efectos.html"></iframe>
                
            </div>

            <button onclick="applyTextToWorkspace()" style="margin-top:20px; font-size:1.1rem; width:100%;">üöÄ GENERAR PEDRER√çA Y CERRAR</button>
        </div>
    </div>

    <div id="exportModal" class="modal-backdrop">
        <div class="modal-content">
            <div class="modal-header">
                <h3 style="margin:0">Seleccionar Formato</h3>
                <button class="close-btn" onclick="closeModal('exportModal')">√ó</button>
            </div>
            <p>El dise√±o se guardar√° en la nube y se descargar√° en:</p>
            <div class="export-grid">
                <div class="export-option" onclick="finalizeExport('svg')">
                    <span class="export-icon">üé®</span>
                    <span class="export-label">SVG</span>
                </div>
                <div class="export-option" onclick="finalizeExport('plt')">
                    <span class="export-icon">üì†</span>
                    <span class="export-label">PLT (HPGL)</span>
                </div>
                <div class="export-option" onclick="finalizeExport('ai')">
                    <span class="export-icon">‚úíÔ∏è</span>
                    <span class="export-label">AI (EPS)</span>
                </div>
            </div>
        </div>
    </div>

    <canvas id="procCanvas" style="display:none;"></canvas>

    <div class="footer">
        Desarrollado por <strong>JES√öS VALLEJO</strong><br>
        <span class="gemini-tag">POWERED BY GEMINI 3 PRO - V3.6 (FULL EFFECTS & TOUCH ZOOM)</span>
        <div style="margin-top:10px; font-style:italic; font-size:0.75rem">
            HERRAMIENTA DE USO EXCLUSIVO PARA EMPLEADOS DE <b>VIVA ROUSS</b> Y <b>MISS ROUSS</b>.
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getFirestore, collection, addDoc, getDocs, query, orderBy, limit, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCngQL1pdqghv2vbjkPycT1Xf0C46f7jYs",
            authDomain: "cirineo-cec21.firebaseapp.com",
            projectId: "cirineo-cec21",
            storageBucket: "cirineo-cec21.firebasestorage.app",
            messagingSenderId: "620210618284",
            appId: "1:620210618284:web:482bab9bf74650fff18409"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // --- GESTI√ìN DE PROYECTOS ---
        window.fetchProjectsFromDB = async () => {
            const list = document.getElementById('galleryList');
            list.innerHTML = '<div style="padding:20px; color:#aaa;">Cargando...</div>';
            try {
                const q = query(collection(db, "proyectos_pedreria"), orderBy("fecha", "desc"), limit(20));
                const querySnapshot = await getDocs(q);
                list.innerHTML = "";
                if(querySnapshot.empty) {
                    list.innerHTML = '<div style="padding:20px;">No hay proyectos.</div>';
                    return;
                }
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const date = data.fecha ? data.fecha.toDate().toLocaleDateString() : "S/F";
                    const safeName = data.nombre_proyecto || "Sin nombre";
                    const li = document.createElement('div');
                    li.className = 'project-item';
                    li.innerHTML = `
                        <div class="p-info"><h4>${safeName}</h4><span>${date} ‚Ä¢ ${data.puntos_total || "?"} pts</span></div>
                        <button class="btn-load" onclick='loadProjectData(${JSON.stringify(data).replace(/'/g, "&#39;")})'>CARGAR</button>
                    `;
                    list.appendChild(li);
                });
            } catch (e) { console.error(e); list.innerHTML = '<div style="color:red">Error cargando lista.</div>'; }
        };

        window.saveToFirebase = async (points, svgString, format) => {
            const name = document.getElementById('projectName').value.trim();
            if(!name) return; 
            try {
                await addDoc(collection(db, "proyectos_pedreria"), {
                    nombre_proyecto: name,
                    puntos_total: points.length,
                    puntos_json: JSON.stringify(points), 
                    svg_generado: svgString,
                    formato_exportado: format,
                    config: window.getLastConfig(),
                    fecha: serverTimestamp(),
                    autor: "JES√öS VALLEJO"
                });
            } catch(e) { console.error("Error DB:", e); }
        };

        // --- GESTI√ìN DE FUENTES ---
        window.fetchFontsFromDB = async () => {
            const list = document.getElementById('fontListDisplay');
            const select = document.getElementById('txtFontFamily');
            list.innerHTML = "Cargando...";
            
            try {
                const q = query(collection(db, "fuentes_usuario"), orderBy("nombre", "asc"));
                const querySnapshot = await getDocs(q);
                
                list.innerHTML = "";
                while (select.options.length > 4) { select.remove(4); }

                querySnapshot.forEach((doc) => {
                    const f = doc.data();
                    const item = document.createElement('div');
                    item.className = 'font-item';
                    item.innerHTML = `<strong>${f.nombre}</strong><span style="font-size:0.7rem; color:#aaa; max-width:150px; overflow:hidden; text-overflow:ellipsis;">${f.url}</span>`;
                    list.appendChild(item);
                    loadFontToBrowser(f.nombre, f.url);
                    const opt = document.createElement('option');
                    opt.value = f.nombre;
                    opt.text = f.nombre + " (Custom)";
                    select.add(opt);
                });
            } catch (e) { console.error(e); list.innerHTML = "Error cargando fuentes."; }
        };

        window.saveNewFont = async () => {
            const name = document.getElementById('newFontName').value.trim();
            const url = document.getElementById('newFontUrl').value.trim();
            if(!name || !url) return alert("Llena ambos campos");
            try {
                await addDoc(collection(db, "fuentes_usuario"), { nombre: name, url: url, fecha: serverTimestamp() });
                alert("Fuente agregada. Se recargar√° la lista.");
                document.getElementById('newFontName').value = "";
                document.getElementById('newFontUrl').value = "";
                window.fetchFontsFromDB();
            } catch(e) { alert("Error guardando fuente."); }
        };

        async function loadFontToBrowser(name, url) {
            try {
                const font = new FontFace(name, `url(${url})`);
                await font.load();
                document.fonts.add(font);
            } catch(e) { console.error("No se pudo cargar la fuente visualmente:", name); }
        }
        
        window.fetchFontsFromDB();
    </script>

    <script>
        // --- ESTADO GLOBAL ---
        let globalPoints = [];     
        let backupPoints = [];     
        let canvasWidth = 1000;       
        let canvasHeight = 1000;
        let isLoadedProject = false; 
        let manualEditsMade = false;
        let currentTextEffect = 'fill';
        
        // --- UI HELPERS ---
        function closeModal(id) { document.getElementById(id).style.display = 'none'; }
        function openGallery() { document.getElementById('galleryModal').style.display = 'flex'; if(window.fetchProjectsFromDB) window.fetchProjectsFromDB(); }
        function openFontManager() { document.getElementById('fontManagerModal').style.display = 'flex'; if(window.fetchFontsFromDB) window.fetchFontsFromDB(); }
        
        // --- COMUNICACI√ìN CON EFECTOS.HTML ---
        window.addEventListener('message', (event) => {
            if (event.data && event.data.action === 'applyEffect') {
                const effectName = event.data.effectName;
                console.log("Efecto activado:", effectName);
                currentTextEffect = effectName;
                updateTextPreview();
            }
        });

        function openTextTool() {
            document.getElementById('textToolModal').style.display = 'flex';
            updateTextPreview();
        }

        // =========================================================================
        // === MOTOR DE RENDERIZADO DE EFECTOS (NUEVO Y COMPLETO) ===
        // =========================================================================
        
        function renderAdvancedEffect(ctx, text, x, y, size, fontName, effect, intensity) {
            ctx.font = `bold ${size}px "${fontName}"`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "white"; // Pedrer√≠a siempre mapea blanco/colores claros
            ctx.strokeStyle = "white";

            switch (effect) {
                // --- B√ÅSICOS ---
                case 'fill':
                case 'pav√©': // Pav√© es relleno s√≥lido para el algoritmo de puntos
                    ctx.fillText(text, x, y);
                    break;
                
                case 'outline':
                case 'negative_box':
                    ctx.lineWidth = size * 0.05;
                    ctx.strokeText(text, x, y);
                    if(effect === 'negative_box') {
                        const m = ctx.measureText(text);
                        ctx.lineWidth = size * 0.02;
                        ctx.strokeRect(x - m.width/2 - 20, y - size/2 - 20, m.width + 40, size + 40);
                    }
                    break;

                // --- NUEVO EFECTO: DISPERSI√ìN (Goteo complejo de las im√°genes) ---
                case 'dispersion':
                    // 1. Dibujar el texto base
                    ctx.fillText(text, x, y);
                    
                    // 2. Generar efecto de goteo en la parte inferior
                    const metrics = ctx.measureText(text);
                    const textWidth = metrics.width;
                    const textHeight = size * 0.8; // Aprox
                    const startX = x - textWidth / 2;
                    const bottomY = y + textHeight / 2;
                    
                    const numDrops = textWidth / (size * 0.1); // Densidad de gotas
                    const maxDropLength = size * (intensity / 20); // Largo basado en intensidad
                    
                    for (let i = 0; i <= numDrops; i++) {
                        const currentX = startX + (i * (textWidth / numDrops));
                        
                        // Aleatoriedad en la longitud de cada estela de goteo
                        const dropLength = Math.random() * maxDropLength + (size * 0.5);
                        const dropSize = size * 0.06; // Tama√±o base de las gotas

                        // Crear la estela de puntos cayendo
                        for (let dy = 0; dy < dropLength; dy += dropSize * 1.5) {
                             // Dispersi√≥n horizontal aleatoria a medida que cae
                            const scatterX = (Math.random() - 0.5) * (dy * 0.2);
                            // El tama√±o de la gota se reduce al caer
                            const currentDropSize = dropSize * (1 - (dy / dropLength) * 0.6);
                            
                            ctx.beginPath();
                            ctx.arc(currentX + scatterX, bottomY + dy, currentDropSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    break;

                // --- DISTORSIONES Y ROTURAS ---
                case 'shatter': // Efecto Versace Roto
                    ctx.save();
                    ctx.fillText(text, x, y);
                    ctx.globalCompositeOperation = 'destination-out';
                    const shards = 20 * (intensity/10);
                    for(let i=0; i<shards; i++) {
                        ctx.beginPath();
                        const sx = x + (Math.random()-0.5) * size * 5;
                        const sy = y + (Math.random()-0.5) * size;
                        ctx.moveTo(sx, sy);
                        ctx.lineTo(sx + 30, sy + 50);
                        ctx.lineTo(sx - 20, sy + 40);
                        ctx.fill();
                    }
                    ctx.restore();
                    break;

                case 'melting': // Goteo simple
                case 'blood': // Drip
                    ctx.fillText(text, x, y);
                    const drops = 15 * (intensity/20);
                    const widthApprox = text.length * (size * 0.6);
                    const startXDrop = x - widthApprox/2;
                    for(let i=0; i<drops; i++) {
                        const dx = startXDrop + Math.random() * widthApprox;
                        const dy = y + size/5;
                        const len = Math.random() * size * 1.5;
                        ctx.beginPath();
                        ctx.arc(dx, dy + len, size*0.05, 0, Math.PI, false); // Punta gota
                        ctx.rect(dx - size*0.05, dy, size*0.1, len);
                        ctx.fill();
                    }
                    break;

                case 'lightning': // Rayo cortando
                    ctx.fillText(text, x, y);
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.moveTo(x - size*2, y - size);
                    let lx = x - size*2, ly = y - size;
                    while(lx < x + size*2) {
                        lx += 20; ly += (Math.random() - 0.5) * 60;
                        ctx.lineTo(lx, ly);
                    }
                    ctx.lineWidth = size * 0.08;
                    ctx.stroke();
                    ctx.globalCompositeOperation = 'source-over';
                    break;

                // --- PATRONES Y RELLENOS ---
                case 'brick':
                case 'camo':
                case 'zebra_v2':
                case 'snake':
                case 'matrix':
                case 'circuit':
                case 'scanline':
                case 'disco':
                    // 1. Dibujar texto base en un canvas temporal para usarlo como m√°scara
                    const mCvs = document.createElement('canvas');
                    mCvs.width = ctx.canvas.width; mCvs.height = ctx.canvas.height;
                    const mCtx = mCvs.getContext('2d');
                    mCtx.font = ctx.font; mCtx.textAlign = "center"; mCtx.textBaseline = "middle";
                    mCtx.fillStyle = "white";
                    mCtx.fillText(text, x, y);

                    // 2. Dibujar el patr√≥n en el canvas principal
                    ctx.save();
                    
                    // Aplicar patr√≥n
                    if (effect === 'brick') {
                        const brickH = size * 0.2; const brickW = size * 0.4;
                        for(let by=0; by<ctx.canvas.height; by+=brickH) {
                            const offset = (Math.floor(by/brickH)%2 === 0) ? 0 : brickW/2;
                            for(let bx=-50; bx<ctx.canvas.width; bx+=brickW) {
                                ctx.strokeRect(bx + offset, by, brickW, brickH);
                            }
                        }
                    } else if (effect === 'matrix') {
                        ctx.font = `${size*0.3}px monospace`;
                        for(let mx=0; mx<ctx.canvas.width; mx+=size*0.3) {
                            for(let my=0; my<ctx.canvas.height; my+=size*0.3) {
                                if(Math.random() > 0.5) ctx.fillText(String.fromCharCode(0x30A0 + Math.random()*96), mx, my);
                            }
                        }
                    } else if (effect === 'scanline') {
                        for(let ly=0; ly<ctx.canvas.height; ly+=size*0.05) {
                            ctx.fillRect(0, ly, ctx.canvas.width, size*0.02);
                        }
                    } else if (effect === 'circuit') {
                         ctx.lineWidth = size * 0.03;
                         for(let i=0; i<50; i++) {
                             ctx.beginPath();
                             ctx.moveTo(Math.random()*ctx.canvas.width, Math.random()*ctx.canvas.height);
                             ctx.lineTo(Math.random()*ctx.canvas.width, Math.random()*ctx.canvas.height);
                             ctx.stroke();
                             ctx.beginPath(); ctx.arc(Math.random()*ctx.canvas.width, Math.random()*ctx.canvas.height, size*0.05, 0, Math.PI*2); ctx.fill();
                         }
                    }

                    // 3. Usar el texto como m√°scara (Composite Operation)
                    ctx.globalCompositeOperation = 'destination-in';
                    ctx.drawImage(mCvs, 0, 0);
                    
                    // 4. Restaurar para que el contorno sea visible si se desea, o dejar solo el relleno
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.restore();
                    // Opcional: Dibujar contorno fino para legibilidad
                    ctx.lineWidth = 1; ctx.strokeText(text, x, y);
                    break;

                // --- ESTILOS DE LUJO ---
                case 'baguette': // Piedras rectangulares (simuladas con dashes)
                    ctx.lineWidth = size * 0.02;
                    ctx.strokeText(text, x, y);
                    ctx.setLineDash([size*0.1, size*0.05]); // Patr√≥n baguette
                    ctx.lineWidth = size * 0.08;
                    ctx.strokeText(text, x, y); // Doble stroke para efecto
                    ctx.setLineDash([]);
                    break;

                case 'gold_dust': // Ruido aleatorio
                case 'sand':
                case 'ice':
                case 'galaxy':
                case 'fading':
                    // Dibujar texto s√≥lido primero
                    const dCvs = document.createElement('canvas');
                    dCvs.width = ctx.canvas.width; dCvs.height = ctx.canvas.height;
                    const dCtx = dCvs.getContext('2d');
                    dCtx.font = ctx.font; dCtx.textAlign = "center"; dCtx.textBaseline = "middle";
                    dCtx.fillStyle = "white";
                    dCtx.fillText(text, x, y);
                    
                    const imgData = dCtx.getImageData(0,0, dCvs.width, dCvs.height);
                    const pixels = imgData.data;
                    
                    // Procesar p√≠xeles para a√±adir ruido
                    for (let i = 0; i < pixels.length; i += 4) {
                        if (pixels[i+3] > 0) { // Si hay pixel
                            let noise = Math.random();
                            let threshold = 0.5;
                            if (effect === 'fading') {
                                // Gradiente vertical basado en Y
                                const py = Math.floor((i / 4) / dCvs.width);
                                threshold = (py - (y - size/2)) / size; // 0 a 1 aprox
                            }
                            if (noise > threshold) {
                                ctx.fillRect((i/4)%dCvs.width, Math.floor((i/4)/dCvs.width), 1, 1);
                            }
                        }
                    }
                    break;

                case 'halo':
                    ctx.fillText(text, x, y);
                    ctx.beginPath();
                    const metricsHalo = ctx.measureText(text);
                    ctx.arc(x, y, metricsHalo.width/2 + 20, 0, Math.PI * 2);
                    ctx.lineWidth = size * 0.05;
                    ctx.stroke();
                    break;

                case 'neon': // M√∫ltiples bordes
                    ctx.lineWidth = size * 0.15; ctx.strokeText(text, x, y);
                    ctx.lineWidth = size * 0.05; ctx.strokeStyle = "black"; ctx.strokeText(text, x, y); // Gap
                    ctx.lineWidth = size * 0.02; ctx.strokeStyle = "white"; ctx.strokeText(text, x, y); // Inner
                    break;
                
                case 'tiara':
                    ctx.fillText(text, x, y);
                    ctx.font = `${size}px "Segoe UI Emoji"`;
                    ctx.fillText("üëë", x, y - size*0.8);
                    break;
                
                case 'royal_cross':
                    ctx.fillText(text, x, y);
                    ctx.font = `${size}px "Segoe UI Emoji"`;
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.fillText("‚úùÔ∏è", x, y);
                    ctx.globalCompositeOperation = 'source-over';
                    break;

                default: // Fallback
                    ctx.fillText(text, x, y);
            }
        }

        // --- ACTUALIZAR VISTA PREVIA (Modal) ---
        function updateTextPreview() {
            const cvs = document.getElementById('textPreviewCanvas');
            const ctx = cvs.getContext('2d');
            const text = document.getElementById('txtString').value;
            const fontName = document.getElementById('txtFontFamily').value;
            const size = parseInt(document.getElementById('rngTxtSize').value);
            const scatter = parseInt(document.getElementById('rngScatter').value);

            // Ajustar canvas para acomodar efectos grandes como Dispersi√≥n
            cvs.width = Math.max(600, text.length * (size * 0.7) + 100);
            cvs.height = size * 3.5; 

            // Fondo "Camiseta"
            ctx.fillStyle = "black";
            ctx.fillRect(0,0,cvs.width, cvs.height);

            const cx = cvs.width / 2;
            const cy = cvs.height / 2.5; // Subir un poco el texto base

            renderAdvancedEffect(ctx, text, cx, cy, size, fontName, currentTextEffect, scatter);
        }

        // --- APLICAR AL WORKSPACE (Generaci√≥n Final) ---
        function applyTextToWorkspace() {
            const previewCvs = document.getElementById('textPreviewCanvas');
            const procCanvas = document.getElementById('procCanvas');
            const ctx = procCanvas.getContext('2d');
            
            // Renderizamos a mayor resoluci√≥n para calidad
            procCanvas.width = previewCvs.width * 2;
            procCanvas.height = previewCvs.height * 2;
            
            const text = document.getElementById('txtString').value;
            const fontName = document.getElementById('txtFontFamily').value;
            const size = parseInt(document.getElementById('rngTxtSize').value) * 2;
            const scatter = parseInt(document.getElementById('rngScatter').value);

            // Fondo blanco para que el generador de puntos detecte lo "negro" o viceversa
            // NOTA IMPORTANTE: El algoritmo generatePoints detecta < 150 (oscuro).
            // Por lo tanto, debemos dibujar el TEXTO EN NEGRO y el FONDO EN BLANCO.
            // Pero mi funci√≥n de renderizado usa "White" para simular piedras sobre fondo negro visualmente.
            // Invertiremos los colores para el procesamiento.
            
            ctx.fillStyle = "white"; // Fondo
            ctx.fillRect(0,0, procCanvas.width, procCanvas.height);
            
            ctx.fillStyle = "black"; // Texto (para ser detectado)
            ctx.strokeStyle = "black";
            
            // Hack temporal: Sobreescribimos fillStyle/strokeStyle del contexto antes de llamar
            // Pero como la funci√≥n renderAdvancedEffect fuerza "white", necesitamos un modo "processing".
            
            // SOLUCI√ìN: Renderizar visualmente (Blanco sobre Negro) y luego INVERTIR la imagen.
            const tempCvs = document.createElement('canvas');
            tempCvs.width = procCanvas.width; tempCvs.height = procCanvas.height;
            const tCtx = tempCvs.getContext('2d');
            tCtx.fillStyle = "black"; tCtx.fillRect(0,0,tempCvs.width, tempCvs.height); // Fondo negro
            
            // Renderizamos el efecto en blanco sobre negro
            renderAdvancedEffect(tCtx, text, procCanvas.width/2, procCanvas.height/2.5, size, fontName, currentTextEffect, scatter);
            
            // Ahora copiamos al canvas de procesamiento e invertimos
            const idata = tCtx.getImageData(0,0, tempCvs.width, tempCvs.height);
            const data = idata.data;
            for(let i=0; i<data.length; i+=4) {
                // Invertir: Lo que era negro (0) se vuelve blanco (255), lo blanco (255) se vuelve negro (0)
                // As√≠ generatePoints detecta el negro como "zona de piedras".
                data[i] = 255 - data[i];     // R
                data[i+1] = 255 - data[i+1]; // G
                data[i+2] = 255 - data[i+2]; // B
            }
            ctx.putImageData(idata, 0, 0);

            canvasWidth = procCanvas.width;
            canvasHeight = procCanvas.height;
            document.getElementById('textToolModal').style.display = 'none';
            document.getElementById('imgInputGroup').style.display = 'none';
            document.getElementById('btnGenerate').style.display = 'block';
            
            generatePoints(ctx);
            renderSVGPreview();
            updateLabels();
            document.getElementById('btnOpenEditor').disabled = false;
        }

        // --- L√ìGICA EXISTENTE ---
        const inputs = document.querySelectorAll('.param-input');
        inputs.forEach(i => i.addEventListener('input', handleParamChange));
        document.getElementById('realWidthCm').addEventListener('input', updateLabels);
        document.getElementById('radius').addEventListener('input', () => { if(isLoadedProject || globalPoints.length > 0) renderSVGPreview(); updateLabels(); });

        function handleParamChange(e) { updateLabels(); }

        function updateLabels() {
            const realW = parseFloat(document.getElementById('realWidthCm').value) || 25;
            const w = canvasWidth > 0 ? canvasWidth : 1000;
            const scaleFactor = (realW * 10) / w; 
            document.getElementById('yStepVal').innerText = (document.getElementById('yStep').value * scaleFactor).toFixed(1);
            document.getElementById('xStepVal').innerText = (document.getElementById('xStep').value * scaleFactor).toFixed(1);
            document.getElementById('angleVal').innerText = document.getElementById('angle').value;
            const rPx = parseFloat(document.getElementById('radius').value);
            document.getElementById('radiusVal').innerText = (rPx * 2 * scaleFactor).toFixed(1);
            if(canvasHeight > 0) {
                const hCm = (canvasHeight * (realW / w)).toFixed(1);
                document.getElementById('dimDisplay').innerText = `Dimensiones Finales: ${realW} cm x ${hCm} cm`;
            }
        }
        window.getLastConfig = () => { return { mode: document.getElementById('mode').value, realWidth: document.getElementById('realWidthCm').value, radiusPx: document.getElementById('radius').value }; }

        window.loadProjectData = (data) => {
            if(confirm("Se reemplazar√° el trabajo actual. ¬øContinuar?")) {
                try {
                    if (data.puntos_json) globalPoints = JSON.parse(data.puntos_json);
                    else alert("Proyecto antiguo no compatible.");
                    document.getElementById('projectName').value = data.nombre_proyecto;
                    isLoadedProject = true;
                    let maxX = 0, maxY = 0;
                    globalPoints.forEach(p => { if(p.x > maxX) maxX = p.x; if(p.y > maxY) maxY = p.y; });
                    canvasWidth = maxX + 50; canvasHeight = maxY + 50;
                    document.getElementById('btnOpenEditor').disabled = false;
                    closeModal('galleryModal');
                    renderSVGPreview(); updateLabels();
                } catch(e) { console.error(e); }
            }
        };

        function processImage() {
            const input = document.getElementById('imageInput');
            const isTextMode = document.getElementById('textToolModal').style.display === 'none' && canvasWidth > 0;
            
            if (!input.files[0] && !isTextMode) return alert("Selecciona imagen o usa el Creador de Texto.");
            
            if (input.files[0]) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const c = document.getElementById('procCanvas');
                        const ctx = c.getContext('2d', { willReadFrequently: true });
                        const maxW = 1000;
                        const scale = maxW / img.width;
                        c.width = maxW; c.height = img.height * scale;
                        canvasWidth = c.width; canvasHeight = c.height;
                        ctx.fillStyle = "white"; ctx.fillRect(0,0,c.width, c.height);
                        ctx.drawImage(img, 0, 0, c.width, c.height);
                        generatePoints(ctx); renderSVGPreview(); updateLabels();
                        document.getElementById('btnOpenEditor').disabled = false;
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(input.files[0]);
            } else {
                const c = document.getElementById('procCanvas');
                const ctx = c.getContext('2d');
                generatePoints(ctx); renderSVGPreview();
            }
        }

        function generatePoints(ctx) {
            const yStep = parseInt(document.getElementById('yStep').value);
            const xStep = parseInt(document.getElementById('xStep').value);
            const angle = parseInt(document.getElementById('angle').value) * (Math.PI / 180);
            const mode = document.getElementById('mode').value;
            const w = ctx.canvas.width; const h = ctx.canvas.height;
            const imgData = ctx.getImageData(0, 0, w, h);
            globalPoints = [];

            for (let y = -h; y < h * 2; y += yStep) {
                let segment = [];
                for (let x = -w; x < w * 2; x += 1) {
                    const rotX = Math.floor(x * Math.cos(angle) - y * Math.sin(angle));
                    const rotY = Math.floor(x * Math.sin(angle) + y * Math.cos(angle));
                    if (rotX >= 0 && rotX < w && rotY >= 0 && rotY < h) {
                        const idx = (rotY * w + rotX) * 4;
                        if (imgData.data[idx] < 150) segment.push({x: rotX, y: rotY});
                        else if (segment.length > 0) { addSegment(segment, xStep, mode); segment = []; }
                    }
                }
                if (segment.length > 0) addSegment(segment, xStep, mode);
            }
        }

        function addSegment(seg, step, mode) {
            if (seg.length < 2) return;
            if (mode === 'adaptive') {
                const count = Math.max(1, Math.round(seg.length / step));
                for(let i=0; i<count; i++) {
                    const idx = Math.floor((seg.length / (count+1)) * (i+1));
                    globalPoints.push(seg[idx]);
                }
            } else { for(let i=0; i<seg.length; i+=step) globalPoints.push(seg[i]); }
        }

        function renderSVGPreview() {
            const r = parseFloat(document.getElementById('radius').value);
            let svg = `<svg viewBox="0 0 ${canvasWidth} ${canvasHeight}" style="max-height:100%; max-width:100%;"><g fill="black">`;
            globalPoints.forEach(p => { svg += `<circle cx="${p.x.toFixed(1)}" cy="${p.y.toFixed(1)}" r="${r}" />`; });
            svg += `</g></svg>`;
            document.getElementById('svgContent').innerHTML = svg;
        }

        // --- EDITOR CANVAS (ZOOM T√ÅCTIL MEJORADO) ---
        const editorCanvas = document.getElementById('editorCanvas');
        const ctxEdit = editorCanvas.getContext('2d');
        let editTool = 'delete'; let selectedPointIdx = -1; let editorScale = 1; let editorOffsetX = 0; let editorOffsetY = 0; 
        let isDragging = false; let lastMouse = {x:0, y:0};
        // Variables para control de zoom t√°ctil
        let initialPinchDistance = 0; let isPinching = false;

        function openEditor() {
            backupPoints = JSON.parse(JSON.stringify(globalPoints)); 
            document.getElementById('editorOverlay').style.display = 'flex';
            const rect = document.getElementById('visualWrapper').getBoundingClientRect();
            editorCanvas.width = rect.width; editorCanvas.height = rect.height;
            editorScale = Math.min(editorCanvas.width / canvasWidth, editorCanvas.height / canvasHeight) * 0.9;
            editorOffsetX = (editorCanvas.width - canvasWidth * editorScale) / 2;
            editorOffsetY = (editorCanvas.height - canvasHeight * editorScale) / 2;
            requestAnimationFrame(drawEditorLoop);
        }

        function setTool(t) { editTool = t; selectedPointIdx = -1; document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active')); document.querySelector(`.tool-btn.${t}`).classList.add('active'); document.getElementById('dpad').style.display = (t === 'move') ? 'grid' : 'none'; drawEditorLoop(); }
        
        function drawEditorLoop() {
            ctxEdit.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
            ctxEdit.save(); ctxEdit.translate(editorOffsetX, editorOffsetY); ctxEdit.scale(editorScale, editorScale);
            ctxEdit.fillStyle = "white"; ctxEdit.fillRect(0,0, canvasWidth, canvasHeight);
            const r = parseFloat(document.getElementById('radius').value);
            for(let i=0; i<globalPoints.length; i++) {
                const p = globalPoints[i];
                ctxEdit.beginPath(); ctxEdit.arc(p.x, p.y, r, 0, Math.PI*2);
                if (editTool === 'delete') { ctxEdit.fillStyle = "black"; ctxEdit.fill(); ctxEdit.lineWidth = r/2; ctxEdit.strokeStyle = "red"; ctxEdit.stroke(); } 
                else if (editTool === 'move' && i === selectedPointIdx) { ctxEdit.fillStyle = "#2196F3"; ctxEdit.fill(); ctxEdit.strokeStyle = "#2196F3"; ctxEdit.lineWidth = 2; ctxEdit.stroke(); }
                else { ctxEdit.fillStyle = "black"; ctxEdit.fill(); }
            }
            ctxEdit.restore();
        }

        function screenToWorld(sx, sy) { return { x: (sx - editorOffsetX) / editorScale, y: (sy - editorOffsetY) / editorScale }; }
        
        // Eventos de Rat√≥n (Pan y Zoom con rueda)
        editorCanvas.addEventListener('mousedown', startPan); editorCanvas.addEventListener('mousemove', movePan); editorCanvas.addEventListener('mouseup', endPan);
        editorCanvas.addEventListener('wheel', (e) => {
            e.preventDefault(); const s = (e.deltaY < 0) ? 1.1 : 0.9;
            const rect = editorCanvas.getBoundingClientRect();
            const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
            editorOffsetX = mx - (mx - editorOffsetX) * s; editorOffsetY = my - (my - editorOffsetY) * s;
            editorScale *= s; drawEditorLoop();
        });
        
        // Eventos T√°ctiles (Pan y Zoom con pellizco)
        editorCanvas.addEventListener('touchstart', (e)=>{ 
            if(e.touches.length === 1) { startPan(e.touches[0]); }
            else if (e.touches.length === 2) {
                isPinching = true;
                initialPinchDistance = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
            }
        });
        editorCanvas.addEventListener('touchmove', (e)=>{ 
            e.preventDefault(); 
            if(e.touches.length === 1 && !isPinching) { movePan(e.touches[0]); }
            else if (isPinching && e.touches.length === 2) {
                const currentDistance = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                const s = currentDistance / initialPinchDistance;
                const rect = editorCanvas.getBoundingClientRect();
                // Punto medio del pellizco para hacer zoom desde ah√≠
                const mx = (e.touches[0].pageX + e.touches[1].pageX) / 2 - rect.left;
                const my = (e.touches[0].pageY + e.touches[1].pageY) / 2 - rect.top;
                editorOffsetX = mx - (mx - editorOffsetX) * s;
                editorOffsetY = my - (my - editorOffsetY) * s;
                editorScale *= s;
                initialPinchDistance = currentDistance; // Actualizar para el siguiente frame
                drawEditorLoop();
            }
        });
        editorCanvas.addEventListener('touchend', (e)=>{ 
            if (isPinching && e.touches.length < 2) { isPinching = false; }
            else if (e.touches.length === 0) { endPan(e.changedTouches[0]); }
        });

        let startClickTime = 0; let didMove = false;
        function startPan(e) { isDragging = true; didMove = false; startClickTime = Date.now(); const rect = editorCanvas.getBoundingClientRect(); lastMouse = { x: (e.clientX || e.pageX) - rect.left, y: (e.clientY || e.pageY) - rect.top }; }
        function movePan(e) { if (!isDragging) return; const rect = editorCanvas.getBoundingClientRect(); const x = (e.clientX || e.pageX) - rect.left; const y = (e.clientY || e.pageY) - rect.top; if (Math.abs(x - lastMouse.x) > 2 || Math.abs(y - lastMouse.y) > 2) didMove = true; editorOffsetX += (x - lastMouse.x); editorOffsetY += (y - lastMouse.y); lastMouse = {x, y}; drawEditorLoop(); }
        function endPan(e) { isDragging = false; const timeDiff = Date.now() - startClickTime; if (timeDiff < 300 && !didMove) { const rect = editorCanvas.getBoundingClientRect(); handleToolClick((e.clientX || e.pageX) - rect.left, (e.clientY || e.pageY) - rect.top); } }

        function handleToolClick(sx, sy) {
            const wPos = screenToWorld(sx, sy); const r = parseFloat(document.getElementById('radius').value);
            let hitIdx = -1; let minDist = r * 2.5; // Tolerancia de clic basada en el radio
            for(let i=0; i<globalPoints.length; i++) { const d = Math.hypot(globalPoints[i].x - wPos.x, globalPoints[i].y - wPos.y); if (d < minDist) { minDist = d; hitIdx = i; } }
            if (editTool === 'delete' && hitIdx !== -1) { globalPoints.splice(hitIdx, 1); manualEditsMade = true; } 
            else if (editTool === 'add' && hitIdx === -1) { globalPoints.push({x: wPos.x, y: wPos.y}); manualEditsMade = true; } 
            else if (editTool === 'move') { if (hitIdx !== -1) selectedPointIdx = hitIdx; else if (selectedPointIdx !== -1) { globalPoints[selectedPointIdx].x = wPos.x; globalPoints[selectedPointIdx].y = wPos.y; manualEditsMade = true; } }
            drawEditorLoop();
        }

        window.nudge = (dx, dy) => { if (selectedPointIdx !== -1) { globalPoints[selectedPointIdx].x += dx; globalPoints[selectedPointIdx].y += dy; manualEditsMade = true; drawEditorLoop(); } };
        window.discardChanges = () => { if(confirm("¬øDescartar?")) { globalPoints = backupPoints; document.getElementById('editorOverlay').style.display = 'none'; manualEditsMade = false; renderSVGPreview(); } };
        window.confirmChanges = () => { if(!document.getElementById('projectName').value.trim()) return alert("Pon nombre al proyecto."); document.getElementById('editorOverlay').style.display = 'none'; renderSVGPreview(); document.getElementById('exportModal').style.display = 'flex'; };

        // --- EXPORTACI√ìN ---
        window.finalizeExport = async (format) => {
            const name = document.getElementById('projectName').value.trim() || "dise√±o";
            const svgString = document.getElementById('svgContent').innerHTML;
            let blob = null; let ext = "";
            if (format === 'svg') { blob = new Blob([svgString], {type: "image/svg+xml"}); ext = ".svg"; } 
            else if (format === 'plt') { blob = new Blob([generatePLT()], {type: "text/plain"}); ext = ".plt"; }
            else if (format === 'ai') { blob = new Blob([generateEPS()], {type: "application/postscript"}); ext = ".ai"; }
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a"); a.href = url; a.download = name + "_JMVN" + ext; a.click();
            if (window.saveToFirebase) await window.saveToFirebase(globalPoints, svgString, format);
            closeModal('exportModal'); alert(`‚úÖ Archivo ${ext} listo.`);
        };

        function generatePLT() {
            const scale = (parseFloat(document.getElementById('realWidthCm').value) * 10 / canvasWidth) * 40;
            const rPlt = (parseFloat(document.getElementById('radius').value) * scale).toFixed(0);
            let plt = "IN;PU;"; 
            globalPoints.forEach(p => { plt += `PU${(p.x * scale).toFixed(0)},${(-p.y * scale).toFixed(0)};CI${rPlt};`; });
            return plt + "PU0,0;IN;";
        }

        function generateEPS() {
            const scale = (parseFloat(document.getElementById('realWidthCm').value) * 28.3465) / canvasWidth;
            const h_pt = canvasHeight * scale; const r = parseFloat(document.getElementById('radius').value) * scale;
            let eps = `%!PS-Adobe-3.0 EPSF-3.0\n%%BoundingBox: 0 0 ${(canvasWidth*scale).toFixed(2)} ${h_pt.toFixed(2)}\n%%Creator: JMVN\n/c { 0 360 arc fill } def\n0 setgray\n`; 
            globalPoints.forEach(p => { eps += `${(p.x * scale).toFixed(2)} ${(h_pt - (p.y * scale)).toFixed(2)} ${r.toFixed(2)} c\n`; });
            return eps + `%%EOF`;
        }
    </script>
</body>
</html>